# 1. c++
## 1.1 function
- std::abs()
- std::round()
- std::swap()
- TGAImage
- TGAColor color={x,x,x,x}
order:BGRA
### 
# 2. LERP
实际上就是斜率
$$
\begin{cases}
t = (x-x_0)\div(x_1-x_0);\\
y = y_0 + t * (y_1-y_0);
\end{cases}
$$
# 3.Optimization
```c++
//oringinal
//LERP 线性插值
void line3(int x_a, int y_a, int x_b, int y_b, TGAImage& framebuffer, TGAColor color)
{
    bool steep = std::abs(x_b-x_a) < std::abs(y_b-y_a);
    if (steep)
    {
        std::swap(x_a, y_a);
        std::swap(x_b, y_b);

    }

    if (x_a > x_b)
    {
        std::swap(x_a,x_b);
        std::swap(y_a,y_b);
    }
    for (int x= x_a; x <= x_b; x ++)
    {
        float t = (x - x_a) / static_cast<float>(x_b-x_a);
        int y = std::round(y_a + t * (y_b-y_a));
        if (steep)
            framebuffer.set(y, x, color);
        else
            framebuffer.set(x, y, color);
    }
    return;
}
```

```c++
//optimization1
void line4(int x_a, int y_a, int x_b, int y_b, TGAImage& framebuffer, TGAColor color)
{
    bool steep = std::abs(x_b - x_a) < std::abs(y_b - y_a);
    if (steep)
    {
        std::swap(x_a, y_a);
        std::swap(x_b, y_b);

    }

    if (x_a > x_b)
    {
        std::swap(x_a, x_b);
        std::swap(y_a, y_b);
    }
    // 此处使用int，c++中对int和float相加的处理是直接截断小数部分，而(x - x_a) / static_cast<float>(x_b - x_a)始终小于一导致小数一直加不上去
    float  y = y_a;
    for (int x = x_a; x <= x_b; x++)
    {

        if (steep)
            framebuffer.set(y, x, color);
        else
            framebuffer.set(x, y, color);
        y += (y_b - y_a) / static_cast<float>(x_b - x_a);
    }
    return;
}
//optimization2
void line5(int x_a, int y_a, int x_b, int y_b, TGAImage& framebuffer, TGAColor color)
{
    bool steep = std::abs(x_b - x_a) < std::abs(y_b - y_a);
    if (steep)
    {
        std::swap(x_a, y_a);
        std::swap(x_b, y_b);

    }

    if (x_a > x_b)
    {
        std::swap(x_a, x_b);
        std::swap(y_a, y_b);
    }
    int  y = y_a;
    float error = 0;
    for (int x = x_a; x <= x_b; x++)
    {
        if (steep)
            framebuffer.set(y, x, color);
        else
            framebuffer.set(x, y, color);
        error += std::abs(y_b - y_a) / static_cast<float>(x_b - x_a);
        if (error >= .5)
        {
            y += y_b > y_a ? 1 : -1;
          error -= 1.;
        }
    }
    return;
}

//optimization3 Bresenham's line-drawing algorithm
void line6(int x_a, int y_a, int x_b, int y_b, TGAImage& framebuffer, TGAColor color)
{
    bool steep = std::abs(x_b - x_a) < std::abs(y_b - y_a);
    if (steep)
    {
        std::swap(x_a, y_a);
        std::swap(x_b, y_b);

    }

    if (x_a > x_b)
    {
        std::swap(x_a, x_b);
        std::swap(y_a, y_b);
    }
    int  y = y_a;
    int ierror = 0;
    for (int x = x_a; x <= x_b; x++)
    {
        if (steep)
            framebuffer.set(y, x, color);
        else
            framebuffer.set(x, y, color);
        ierror += 2 * std::abs(y_b - y_a);
        if (ierror >= x_b-x_a)
        {
            y += y_b > y_a ? 1 : -1;
            ierror -= 2 * (x_b - x_a);
        }
    }
    return;
}
```
- steep
  - 通过判断x y的陡峭程度选择对应的t作为单调递增对象，如果x比较陡，就换成y
- error
  - 通过计算当前y（如果swap就是x）在该像素的0.5像素以上还是以下，以上时y根据y_b y_a判断是递增还是递减
- ierror
  - 将浮点数error转换为整数运算,实际上性能没有提高多少,但是这是Bresenham's algorithm在过去为了解决60年代浮点数运算很困难这个问题而写出的全整数运算算法，很有革新意义
# PROBLEM
- 1.integer 整数截断
```c++
int y = y_a; 
// ...
y += (x - x_a) / static_cast<float>(x_b - x_a);
```
>由于y为int，加的为float且这个值始终小于1，导致一致没有加上去
- 2.error、ierror底层逻辑
> 将斜率累加，并通过.5的限制进位来实现y的移动
> ierror就是将斜率累加变为y_b - y_a的分母的两倍累加,通过直接和x_b - x_a的比较将斜率累加变为纯整数累加比较
- 3.